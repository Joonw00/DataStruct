#c를 파이썬으로 옮긴 거라 에러 많이 뜨는데, 수정하기 귀찮아서 그냥 둠
#재귀함수를 이용한 퀵 정렬 이라는 개념만 이해하고, 구현방식에 집중 하지 말 것,어차피 이거 실행 안됨

#재귀함수 이용해보기
def quickSort(data, start, end):    #start,end:정렬을 수행하는 부분집합의 첫번째와 마지막
    if start>=end:  #원소가 1개인 경우
        return
    key = start #pivot값
    i = start +1   #i:왼쪽부터 하나씩 큰 값을 찾을 때의 인덱스,우측으로가며 key값보다 큰 것을 찾으므로 +1을 계산
    j = end        #j:오른쪽 출발 지점

    while i<=j: #엇갈릴 때 까지 반복
        while data[i] <= data[key]: #키 값보다 큰 값을 만날 때 까지 오른쪽으로 이동
            i+=1
        while data[j] >=data[key] and j>start:  
            #*****키 값보다 작은 값을 만날 때 까지 반복//and이후의 설정으로 조건의 값이 없을 때의 상황을 방지(start이전으로 넘어가지 않도록 함)
            #교체 시 왼쪽의 값과 키값을 교체하므로 왼쪽으로만 넘어가지 않도록 설정하면됨(i에 대해서는 설정할 필요 없음)
            j-=1          
        if i>j: #현재 엇갈린 상태면 키 값과 왼쪽의 값교체                     
            temp = data[j]
            data[j] = data[key]
            data[key] = temp
        else:   #엇갈리지 않았다면 큰값과 작은 값을 서로 바꿔 줌
            temp = data[j]
            data[j] = data[i]
            data[i] = temp   

        quickSort(data,start,j-1)   #키 값을 기준으로 왼쪽과 오른쪽에서 각각 다시 퀵 정렬을 시행함

        quickSort(data,j+1, end)    #여기서 range에러 존내 뜸


data = [1,10,5,8,7,6,4,3,2,9]
quickSort(data, 0,9)
print(data)



#평균적인 시간복잡도는 로그 함수이다
#약점:피벗값을 설정하는 것에 따라서 최악의 시간 복잡도는 n^2까지 가게 된다(분할정복의 이점을 활용하지 못할 때:이미 정렬에 가까울 때:삽입정렬과 반대)

#응용문제:내림차순
#퀵정렬은 기본적으로 큰값과 작은 값을 바꾸는 것이다.
#이후 왼쪽의 값과 피벗값을 바꿈
#내림 차순 정렬시에는, 큰값을 찾는 위치와 작은 값을 찾는 위치만 바꿔주면 된다.(2개의 while문에서 부등호의 방향만 바꿔주면 됨)